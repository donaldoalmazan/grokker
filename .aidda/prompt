brainstorm parallelizing the aidda workflow

The goal is to do as much in parallel as possible, particularly API
calls and test runs, so that the user doesn't have to wait for one
step to finish before starting the next.

A secondary goal is to avoid using git's networking or merge features,
including pull, push, fetch, and merge, as much as possible, to encourage
us to develop a better decentralized workflow.

Imagine a scenario where there is a 'watch' subcommand which would:

- start two daemons in the background:
    - watch daemon (W)
    - temporary repo daemon (R)
- the watch daemon would:
    - watch the A prompt file for changes
        - when a prompt file change is detected, it would create a CBOR
          message containing the prompt file contents and the A HEAD commit
          hash (C), and send it to R, promising to respond to any follow-up
          queries for C and its prerequisites
    - listen for messages from R
    - when receiving an object message from R, it would:
        - add the object to A
    - when receiving a commit message from R, it would somehow notify the user
        that changes are ready to be merged
    - when receving an object request from R, it would:
        - send a message to R containing the requested objects
- R would:
    - listen for messages from W
    - when receiving an object message from W, it would:
        - add the object to T
    - when receiving a prompt message, it would:
        - check T for C
            - if C is not found, it would:
                - send a message to W containing the latest commit
                  hash in T, asking for the contents of the objects
                  that make up C and its prerequisites, promising to
                  generate code from the prompt.
                - re-add the message to the tail of the queue
            - if C is found, it would:
                - check out C into a new branch (B)
                - run the generate subcommand in T based on the queued prompt file contents
                - run the test subcommand in T
                - if the tests pass, it would:
                    - commit the changes in T to the B branch 
                    - send a message to W containing the commit hash of B
                - if the tests fail, it would:
                    - append the test output to the prompt file and run the generate
                      subcommand in T again, repeating the process
- when the user receives the notification of changes ready to be
  merged, they would somehow notify W to merge the changes.  The
  daemon would:
    - stash any uncommitted changes in A
    - merge from Tx to A without committing, resolving any merge conflicts 
    - run the test subcommand in A
    - show the user the test results
    - stop, waiting for the user to review the changes and commit them
    - when the user is done reviewing, they would somehow notify the
      daemon to either commit the changes in A or reject them with an
      updated prompt file
- when W receives the notification to commit, it would:
    - commit the changes in A
    - unstash any stashed changes


In: 
    v3/aidda/aidda.go 
    v3/aidda/aidda_test.go
Out: 
    v3/aidda/BRAINSTORM.md
.stop


