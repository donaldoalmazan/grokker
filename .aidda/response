File: /home/stevegt/lab/grokker/v3/aidda/aidda.go
```go
package aidda

import (
	"bufio"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"

	gitignore "github.com/sabhiram/go-gitignore"
	"github.com/stevegt/envi"
	. "github.com/stevegt/goadapt"
	"github.com/stevegt/grokker/v3/core"
	"github.com/stevegt/grokker/v3/util"
)

/*
- while true
	- git commit
	- present user with an editor buffer where they can type a natural language instruction
	- send that along with all files to GPT API
		- filter out files using .aidda/ignore
	- save returned files over top of the existing files
	- run 'git difftool' with vscode as in https://www.roboleary.net/vscode/2020/09/15/vscode-git.html
	- open diff tool in editor so user can selectively choose and edit changes
	- run go test -v
	- include test results in the .aidda/test file
*/

var (
	baseDir  string
	ignoreFn string
)

var DefaultSysmsg = "You are an expert Go programmer. Please make the requested changes to the given code or documentation."

func Do(g *core.Grokker, args ...string) (err error) {
	defer Return(&err)

	baseDir = g.Root

	// ensure we're in a git repository
	_, err = os.Stat(Spf("%s/.git", baseDir))
	Ck(err)

	// create a directory for aidda files
	dir := Spf("%s/.aidda", baseDir)
	err = os.MkdirAll(dir, 0755)
	Ck(err)

	// generate filenames
	promptFn := Spf("%s/prompt", dir)
	ignoreFn = Spf("%s/ignore", dir)
	testFn := Spf("%s/test", dir)

	// ensure there is an ignore file
	err = ensureIgnoreFile(ignoreFn)
	Ck(err)

	// create the prompt file if it doesn't exist
	_, err = NewPrompt(promptFn)
	Ck(err)

	// if the test file is newer than any input files, then include
	// the test results in the prompt, otherwise clear the test file
	testResults := ""
	testStat, err := os.Stat(testFn)
	if os.IsNotExist(err) {
		err = nil
	} else {
		Ck(err)
		// get the list of input files
		p, err := getPrompt(promptFn)
		Ck(err)
		inFns := p.In
		// check if the test file is newer than any input files
		for _, fn := range inFns {
			inStat, err := os.Stat(fn)
			Ck(err)
			if testStat.ModTime().After(inStat.ModTime()) {
				// include the test results in the prompt
				buf, err := ioutil.ReadFile(testFn)
				Ck(err)
				testResults = string(buf)
				break
			}
		}
	}
	if len(testResults) == 0 {
		// clear the test file
		Pl("Clearing test file")
		err = ioutil.WriteFile(testFn, []byte{}, 0644)
		Ck(err)
	}

	for i := 0; i < len(args); i++ {
		cmd := args[i]
		Pl("aidda: running subcommand", cmd)
		switch cmd {
		case "init":
			// already done by this point, so this is a no-op
		case "commit":
			// commit the current state
			err = commit(g)
			Ck(err)
		case "prompt":
			p, err := getPrompt(promptFn)
			Ck(err)
			// spew.Dump(p)
			err = getChanges(g, p, testResults)
			Ck(err)
		case "diff":
			err = runDiff()
			Ck(err)
		case "test":
			err = runTest(testFn)
			Ck(err)
		default:
			PrintUsageAndExit()
		}
	}

	return
}

func PrintUsageAndExit() {
	fmt.Println("Usage: go run main.go {subcommand ...}")
	fmt.Println("Subcommands:")
	fmt.Println("  commit  - Commit the current state")
	fmt.Println("  prompt  - Present the user with an editor to type a prompt and get changes from GPT")
	fmt.Println("  diff    - Run 'git difftool' to review changes")
	fmt.Println("  test    - Run tests and include the results in the prompt file")
	os.Exit(1)
}

// Prompt is a struct that represents a prompt
type Prompt struct {
	Sysmsg string
	In     []string
	Out    []string
	Txt    string
}

// NewPrompt opens or creates a prompt object
func NewPrompt(path string) (p *Prompt, err error) {
	defer Return(&err)
	// check if the file exists
	_, err = os.Stat(path)
	if os.IsNotExist(err) {
		err = createPromptFile(path)
		Ck(err)
	} else {
		Ck(err)
	}
	p, err = readPrompt(path)
	Ck(err)
	return
}

// readPrompt reads a prompt file
func readPrompt(path string) (p *Prompt, err error) {
	defer Return(&err)
	p = &Prompt{}

	// Read entire content of the file
	rawBuf, err := ioutil.ReadFile(path)
	Ck(err)

	content := string(rawBuf)

	// Ensure there is a blank line after the first line
	lines := strings.Split(content, "\n")
	if len(lines) < 2 {
		return nil, fmt.Errorf("prompt file must have at least two lines")
	}
	if lines[1] != "" {
		return nil, fmt.Errorf("prompt file must have a blank line after the first line")
	}

	// Find the index where headers start
	hdrStart := len(lines)
	for i := len(lines) - 1; i >= 0; i-- {
		line := lines[i]
		if strings.TrimSpace(line) == "" {
			// Skip empty lines at the end
			continue
		}
		if strings.Contains(line, ":") {
			// Found a header
			hdrStart = i
		} else {
			// Not a header line, headers start from hdrStart
			hdrStart = i + 1
			break
		}
	}

	if hdrStart >= len(lines) {
		return nil, fmt.Errorf("no headers found at the end of the prompt file")
	}

	// Extract headers
	headers := lines[hdrStart:]
	headerMap := make(map[string]string)
	for _, h := range headers {
		if h == "" {
			continue
		}
		parts := strings.SplitN(h, ":", 2)
		if len(parts) != 2 {
			continue
		}
		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])
		headerMap[key] = value
	}

	// Extract prompt text (lines from after the blank line to hdrStart)
	promptLines := lines[2:hdrStart]
	p.Txt = strings.Join(promptLines, "\n")

	// Process headers
	p.Sysmsg = headerMap["Sysmsg"]
	inStr := headerMap["In"]
	outStr := headerMap["Out"]

	// filenames are space-separated
	p.In = strings.Fields(inStr)
	p.Out = strings.Fields(outStr)

	// Files are relative to the parent of the .aidda directory
	// unless they are absolute paths
	aiddaDir := filepath.Dir(path)
	parentDir := filepath.Dir(aiddaDir)

	// Convert p.In to absolute paths
	newIn := []string{}
	for _, f := range p.In {
		if filepath.IsAbs(f) {
			newIn = append(newIn, f)
		} else {
			newIn = append(newIn, filepath.Join(parentDir, f))
		}
	}
	p.In = newIn

	// Similarly for p.Out
	newOut := []string{}
	for _, f := range p.Out {
		if filepath.IsAbs(f) {
			newOut = append(newOut, f)
		} else {
			newOut = append(newOut, filepath.Join(parentDir, f))
		}
	}
	p.Out = newOut

	// Handle directories in p.In
	for i := 0; i < len(p.In); i++ {
		f := p.In[i]
		fi, err := os.Stat(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %v", f, err)
		}
		if fi.IsDir() {
			files, err := getFilesInDir(f)
			Ck(err)
			p.In = append(p.In[:i], append(files, p.In[i+1:]...)...)
			i += len(files) - 1
		}
	}

	return p, nil
}

// getFilesInDir returns a list of files in a directory
func getFilesInDir(dir string) (files []string, err error) {
	defer Return(&err)

	// get ignore list
	ig, err := gitignore.CompileIgnoreFile(ignoreFn)
	Ck(err)

	files = []string{}
	err = filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		// if path is a directory, skip it
		if info.IsDir() {
			return nil
		}
		// check if the file is in the ignore list
		if ig.MatchesPath(path) {
			return nil
		}
		// only include regular files
		if !info.Mode().IsRegular() {
			return nil
		}
		files = append(files, path)
		return nil
	})
	return files, err
}

// createPromptFile creates a new prompt file
func createPromptFile(path string) (err error) {
	defer Return(&err)
	file, err := os.Create(path)
	Ck(err)
	defer file.Close()

	// get the list of files to process
	inFns, err := getFiles()
	Ck(err)
	outFns := make([]string, len(inFns))
	copy(outFns, inFns)

	// filenames are space-separated
	inStr := strings.Join(inFns, " ")
	outStr := strings.Join(outFns, " ")

	// write the initial prompt line and a blank line
	_, err = io.WriteString(file, "# enter prompt here\n\n")
	Ck(err)

	// write the headers at the end
	_, err = io.WriteString(file, fmt.Sprintf("Sysmsg: %s\n", DefaultSysmsg))
	Ck(err)
	_, err = io.WriteString(file, fmt.Sprintf("In: %s\n", inStr))
	Ck(err)
	_, err = io.WriteString(file, fmt.Sprintf("Out: %s\n", outStr))
	Ck(err)

	return
}

// ask asks the user a question and gets a response
func ask(question, deflt string, others ...string) (response string, err error) {
	defer Return(&err)
	var candidates []string
	candidates = append(candidates, strings.ToUpper(deflt))
	for _, o := range others {
		candidates = append(candidates, strings.ToLower(o))
	}
	for {
		fmt.Printf("%s [%s]: ", question, strings.Join(candidates, "/"))
		reader := bufio.NewReader(os.Stdin)
		response, err = reader.ReadString('\n')
		Ck(err)
		response = strings.TrimSpace(response)
		if response == "" {
			response = deflt
		}
		if len(others) == 0 {
			// if others is empty, return the response without
			// checking candidates
			return
		}
		// check if the response is in the list of candidates
		for _, c := range candidates {
			if strings.ToLower(response) == strings.ToLower(c) {
				return
			}
		}
	}
}

func runTest(fn string) (err error) {
	defer Return(&err)
	Pf("Running tests\n")

	// run go test -v
	stdout, stderr, _, _ := RunTee("go test -v")

	// write test results to the file
	fh, err := os.Create(fn)
	Ck(err)
	_, err = fh.WriteString(Spf("\n\nstdout:\n%s\n\nstderr:%s\n\n", stdout, stderr))
	Ck(err)
	fh.Close()
	return err
}

func runDiff() (err error) {
	defer Return(&err)
	// run difftool
	difftool := envi.String("AIDDA_DIFFTOOL", "git difftool")
	Pf("Running difftool %s\n", difftool)
	var rc int
	rc, err = RunInteractive(difftool)
	Ck(err)
	Assert(rc == 0, "difftool failed")
	return err
}

func getChanges(g *core.Grokker, p *Prompt, testResults string) (err error) {
	defer Return(&err)

	if len(testResults) > 0 {
		Pl("Including test results in prompt")
	}
	prompt := Spf("%s\n\n%s", p.Txt, testResults)
	inFns := p.In
	outFns := p.Out
	var outFls []core.FileLang
	for _, fn := range outFns {
		lang, known, err := util.Ext2Lang(fn)
		Ck(err)
		if !known {
			Pf("Unknown language for file %s, defaulting to %s\n", fn, lang)
		}
		outFls = append(outFls, core.FileLang{File: fn, Language: lang})
	}

	sysmsg := p.Sysmsg
	if sysmsg == "" {
		Pf("Sysmsg header missing, using default.")
		sysmsg = DefaultSysmsg
	}
	Pf("Sysmsg: %s\n", sysmsg)

	msgs := []core.ChatMsg{
		core.ChatMsg{Role: "USER", Txt: prompt},
	}

	// count tokens
	Pf("Token counts:\n")
	tcs := newTokenCounts(g)
	tcs.add("sysmsg", sysmsg)
	txt := ""
	for _, m := range msgs {
		txt += m.Txt
	}
	tcs.add("msgs", txt)
	for _, f := range inFns {
		var buf []byte
		buf, err = ioutil.ReadFile(f)
		Ck(err)
		txt = string(buf)
		tcs.add(f, txt)
	}
	tcs.showTokenCounts()

	Pl("Output files:")
	for _, f := range outFns {
		Pl(f)
	}

	Pf("Querying GPT...")
	// start a goroutine to print dots while waiting for the response
	var stopDots = make(chan bool)
	go func() {
		for {
			select {
			case <-stopDots:
				return
			default:
				time.Sleep(1 * time.Second)
				fmt.Print(".")
			}
		}
	}()
	start := time.Now()
	resp, err := g.SendWithFiles(sysmsg, msgs, inFns, outFls)
	Ck(err)
	elapsed := time.Since(start)
	stopDots <- true
	close(stopDots)
	Pf(" got response in %s\n", elapsed)

	// ExtractFiles(outFls, promptFrag, dryrun, extractToStdout)
	err = core.ExtractFiles(outFls, resp, false, false)
	Ck(err)

	// write entire response to .aidda/response
	Assert(len(baseDir) > 0, "baseDir not set")
	respFn := Spf("%s/.aidda/response", baseDir)
	err = ioutil.WriteFile(respFn, []byte(resp), 0644)
	Ck(err)

	return
}

type tokenCount struct {
	name  string
	text  string
	count int
}

type tokenCounts struct {
	g      *core.Grokker
	counts []tokenCount
}

// newTokenCounts creates a new tokenCounts object
func newTokenCounts(g *core.Grokker) *tokenCounts {
	return &tokenCounts{g: g}
}

// add adds a token count to a tokenCounts object
func (tcs *tokenCounts) add(name, text string) {
	count, err := tcs.g.TokenCount(text)
	Ck(err)
	tc := tokenCount{name: name, text: text, count: count}
	tcs.counts = append(tcs.counts, tc)
	return
}

// showTokenCounts shows the token counts for a slice of tokenCount
func (tcs *tokenCounts) showTokenCounts() {
	// first find max width of name
	maxNameLen := 0
	for _, tc := range tcs.counts {
		if len(tc.name) > maxNameLen {
			maxNameLen = len(tc.name)
		}
	}
	// then print the counts
	total := 0
	format := fmt.Sprintf("    %%-%ds: %%7d\n", maxNameLen)
	for _, tc := range tcs.counts {
		Pf(format, tc.name, tc.count)
		total += tc.count
	}
	// then print the total
	Pf(format, "total", total)
}

func getPrompt(promptFn string) (p *Prompt, err error) {
	defer Return(&err)

	// create fsnotify watcher
	// watcher, err := fsnotify.NewWatcher()
	// Ck(err)
	// defer watcher.Close()
	// watch the prompt file
	// err = watcher.Add(promptFn)
	// Ck(err)

	// if AIDDA_EDITOR is set, open the editor where the users can
	// type a natural language instruction
	editor := envi.String("AIDDA_EDITOR", "")
	if editor != "" {
		Pf("Opening editor %s\n", editor)
		rc, err := RunInteractive(Spf("%s %s", editor, promptFn))
		Ck(err)
		Assert(rc == 0, "editor failed")
	}

	// re-read the prompt file
	p, err = NewPrompt(promptFn)
	Ck(err)

	return p, err
}

func commit(g *core.Grokker) (err error) {
	defer Return(&err)
	var rc int

	promptFn := filepath.Join(g.Root, ".aidda", "prompt")
	stampFn := filepath.Join(g.Root, ".aidda", "prompt-stamp")

	// Get modification times
	promptStat, err := os.Stat(promptFn)
	Ck(err)

	stampStat, err := os.Stat(stampFn)
	if os.IsNotExist(err) {
		// Stamp file doesn't exist; proceed
		err = nil
	} else if !promptStat.ModTime().After(stampStat.ModTime()) {
		// Prompt file has not been edited since last commit
		return fmt.Errorf("prompt file has not been edited since last commit. Refusing to commit.")
	}

	// check git status for uncommitted changes
	stdout, stderr, rc, err := Run("git status --porcelain", nil)
	Ck(err)
	if len(stdout) > 0 {
		Pl(string(stdout))
		Pl(string(stderr))
		// git add
		rc, err = RunInteractive("git add -A")
		Assert(rc == 0, "git add failed")
		Ck(err)
		// Use .aidda/prompt as commit message
		commitMsg, err := ioutil.ReadFile(promptFn)
		Ck(err)
		// git commit
		stdout, stderr, rc, err := Run("git commit -F-", commitMsg)
		Assert(rc == 0, "git commit failed")
		Ck(err)
		Pl(string(stdout))
		Pl(string(stderr))
		// Update stamp file
		now := time.Now()
		err = ioutil.WriteFile(stampFn, []byte{}, 0644)
		Ck(err)
		err = os.Chtimes(stampFn, now, now)
		Ck(err)
	} else {
		Pl("Nothing to commit")
	}
	return err
}

// getFiles returns a list of files to be processed
func getFiles() (files []string, err error) {
	defer Return(&err)

	// get ignore list
	ignoreFn := ".aidda/ignore"
	ig, err := gitignore.CompileIgnoreFile(ignoreFn)
	Ck(err)

	// get list of files recursively
	files = []string{}
	err = filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
		// ignore .git and .aidda directories
		if strings.Contains(path, ".git") || strings.Contains(path, ".aidda") {
			return nil
		}
		// check if the file is in the ignore list
		if ig.MatchesPath(path) {
			return nil
		}
		// skip non-files
		if info.IsDir() {
			return nil
		}
		if !info.Mode().IsRegular() {
			return nil
		}
		// add the file to the list
		files = append(files, path)
		return nil
	})
	Ck(err)
	return files, nil
}

// ensureIgnoreFile creates an ignore file if it doesn't exist
func ensureIgnoreFile(fn string) (err error) {
	defer Return(&err)
	// check if the ignore file exists
	_, err = os.Stat(fn)
	if os.IsNotExist(err) {
		err = nil
		// create the ignore file
		fh, err := os.Create(fn)
		Ck(err)
		defer fh.Close()
		// write the default ignore patterns
		_, err = fh.WriteString(".git\n.idea\n.grok*\ngo.*\nnv.shada\n")
		Ck(err)
	}
	return err
}
```
EOF_/home/stevegt/lab/grokker/v3/aidda/aidda.go

File: /home/stevegt/lab/grokker/v3/aidda/aidda_test.go
```go
package aidda

import (
	"bytes"
	"io/ioutil"
	"os"
	"os/exec"
	"testing"
)

func TestRunTee(t *testing.T) {
	// Use 'echo' command for testing
	stdout, stderr, rc, err := RunTee("echo Hello, World!")
	if err != nil {
		t.Fatalf("RunTee failed: %v", err)
	}
	if rc != 0 {
		t.Fatalf("Expected return code 0, got: %d", rc)
	}
	if !bytes.Contains(stdout, []byte("Hello, World!")) {
		t.Errorf("Expected 'Hello, World!' in stdout, got: %s", stdout)
	}
	if len(stderr) != 0 {
		t.Errorf("Expected empty stderr, got: %s", stderr)
	}
}

func TestRun(t *testing.T) {
	// Use 'echo' command for testing
	stdout, stderr, rc, err := Run("echo Hello, Test!", nil)
	if err != nil {
		t.Fatalf("Run failed: %v", err)
	}
	if rc != 0 {
		t.Fatalf("Expected return code 0, got: %d", rc)
	}
	if !bytes.Contains(stdout, []byte("Hello, Test!")) {
		t.Errorf("Expected 'Hello, Test!' in stdout, got: %s", stdout)
	}
	if len(stderr) != 0 {
		t.Errorf("Expected empty stderr, got: %s", stderr)
	}
}

func TestRunInteractive(t *testing.T) {
	if os.Getenv("TEST_INTERACTIVE") == "1" {
		rc, err := RunInteractive("echo Hello, Interactive!")
		if err != nil {
			t.Fatalf("RunInteractive failed: %v", err)
		}
		if rc != 0 {
			t.Fatalf("Expected return code 0, got: %d", rc)
		}
		return
	}
	cmd := exec.Command(os.Args[0], "-test.run=TestRunInteractive")
	cmd.Env = append(os.Environ(), "TEST_INTERACTIVE=1")
	stdout, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("RunInteractive command failed: %v", err)
	}
	if !bytes.Contains(stdout, []byte("Hello, Interactive!")) {
		t.Errorf("Expected 'Hello, Interactive!' in output, got: %s", stdout)
	}
}

func TestReadPrompt(t *testing.T) {
	// Create a temporary file
	promptContent := `# This is a test prompt

Please make changes to the code.

Sysmsg: Test system message
In: input1.go input2.go
Out: output1.go output2.go
`
	tmpFile, err := os.CreateTemp("", "prompt")
	if err != nil {
		t.Fatalf("Failed to create temp file: %v", err)
	}
	defer os.Remove(tmpFile.Name())

	if _, err := tmpFile.WriteString(promptContent); err != nil {
		t.Fatalf("Failed to write to temp file: %v", err)
	}
	tmpFile.Close()

	p, err := readPrompt(tmpFile.Name())
	if err != nil {
		t.Fatalf("readPrompt failed: %v", err)
	}

	expectedTxt := "Please make changes to the code.\n"
	if p.Txt != expectedTxt {
		t.Errorf("Expected Txt to be %q, got %q", expectedTxt, p.Txt)
	}

	if p.Sysmsg != "Test system message" {
		t.Errorf("Expected Sysmsg to be %q, got %q", "Test system message", p.Sysmsg)
	}

	expectedIn := []string{"input1.go", "input2.go"}
	if len(p.In) != len(expectedIn) {
		t.Errorf("Expected In to have %d items, got %d", len(expectedIn), len(p.In))
	}

	expectedOut := []string{"output1.go", "output2.go"}
	if len(p.Out) != len(expectedOut) {
		t.Errorf("Expected Out to have %d items, got %d", len(expectedOut), len(p.Out))
	}
}
```
EOF_/home/stevegt/lab/grokker/v3/aidda/aidda_test.go