add a test case for continuation lines in headers

In: v3/aidda/aidda.go v3/aidda/aidda_test.go
Out: v3/aidda/aidda.go v3/aidda/aidda_test.go
.stop

move the logic for state management to its own set of methods on a struct

.stop

add auto subcommand test case


remove diff subcommand

- update the tests 

.stop

- move the header extraction logic to a separate function

.stop

The user's workflow will be as follows:
- edit `.aidda/prompt` to describe the changes to be created
- run `aidda prompt` to ask the LLM to generate the changes
- optionally repeat the previous step until the prompt file and
  changes are satisfactory
- run `aidda commit` to commit the changes with the prompt file as the
  commit message

Alternative workflow:
- edit `.aidda/prompt` to describe the changes to be created
- run `aidda auto`.  If the prompt file has been edited since the last
  commit, AIDDA will not commit and will generate the changes.  If
  the prompt file has not been edited since the last commit, AIDDA
  will commit the changes with the prompt file as the commit message
  and will not generate any changes.

.stop

In: v3/
Out:
    v3/cli/cli.go
    v3/core/api.go
    v3/core/grokker.go
    v3/core/model.go



To enable overriding the model using a `-model` flag on the command line for all subcommands without changing the model name stored in `.grok`, you'll need to make several changes across your Go codebase. Below, I'll describe the required changes and list the files that need to be modified.

### Overview of Changes

1. **Add a Global `-model` Flag**: Introduce a global `-model` flag that applies to all subcommands in your CLI application using the Kong library.

2. **Modify `cli.go`**: Update the command-line parsing logic to handle the global `-model` flag. Ensure it can override the model during runtime without persisting the change to `.grok`.

3. **Adjust Grokker Initialization**: In the core package, modify how the `Grokker` instance is initialized to accept the overridden model from the command line if provided.

4. **Ensure Non-Persistence of Model Change**: Prevent the overridden model from being saved back to the `.grok` configuration file.

### Detailed Changes

#### 1. Add a Global `-model` Flag in `cli.go`

The Kong library allows you to define global flags that are accessible across all subcommands. Modify the CLI struct to include the `Model` field at the global level.

```go
type CLI struct {
    Model   string   `name:"model" help:"Override the model to use during execution."`
    Verbose bool     `short:"v" help:"Show debug and progress information on stderr."`
    // ... existing subcommands ...
}
```

By adding the `Model` field at the root of the `CLI` struct, Kong will recognize `-model` as a global flag.

#### 2. Modify Command-Line Parsing in `cli.go`

In your `Cli` function, after parsing the arguments, check if the `Model` flag has been provided and, if so, pass it to the `Grokker` initialization. Adjust the initialization logic to accept an optional model parameter.

```go
// After parsing with Kong
ctx, err := parser.Parse(args)
parser.FatalIfErrorf(err)

// ... existing code ...

var grok *core.Grokker
var save bool
var modelOverride string

// Check if the global model flag is set
if cli.Model != "" {
    modelOverride = cli.Model
}

if needsDb {
    var migrated bool
    var was, now string
    var lock *flock.Flock

    // Pass the modelOverride to Load function
    grok, migrated, was, now, lock, err = core.Load(modelOverride, readonly)
    // ... existing error handling and migration logic ...
}
```

#### 3. Update `core.Load` and Related Functions in `core/api.go`

Modify the `Load` function (and any functions it calls) to accept an optional model parameter. If the model is provided via the command line, use it during the initialization of the `Grokker` instance without updating the stored model in `.grok`.

```go
// In core/api.go

func Load(modelOverride string, readonly bool) (g *Grokker, migrated bool, oldver, newver string, lock *flock.Flock, err error) {
    // ... existing code to find the .grok file ...

    g, migrated, oldver, newver, lock, err = LoadFrom(grokpath,
    modelOverride, readonly)
    return
}

func LoadFrom(grokpath string, modelOverride string, readonly bool) (g *Grokker, migrated bool, oldver, newver string, lock *flock.Flock, err error) {
    // ... existing loading logic ...

    // Setup grokker with the model, giving precedence to
    // modelOverride
    modelChoice := modelOverride
    if modelChoice == "" {
        modelChoice = g.Model // Use model from .grok if no override
    }

    err = g.Setup(modelChoice)
    Ck(err)

    return
}
```

#### 4. Prevent Overridden Model from Being Saved in `.grok`

Ensure that when `g.Save()` is called, it doesn't overwrite the model in `.grok` if the model was overridden via the command line.

In the `Grokker` struct, you can add a flag to indicate that the model has been overridden temporarily.

```go
// In core/grokker.go

type Grokker struct {
    // ... existing fields ...
    ModelOverride bool `json:"-"`
}
```

Modify the `SetModel` method to accept an additional parameter or set
the `ModelOverride` flag.

```go
func (g *Grokker) SetModel(model string, overridden bool) (oldModel string, err error) {
    // ... existing code ...

    g.ModelOverride = overridden
    return
}
```

Then, in the `Save` method, check this flag before writing the model to the file.

```go
func (g *Grokker) Save() (err error) {
    defer Return(&err)

    if g.ModelOverride {
        // Temporarily store the model
        originalModel := g.Model

        // Revert to the stored model
        g.Model = g.modelFromGrokFile

        // Proceed with saving
        // ... existing save logic ...

        // Restore the overridden model
        g.Model = originalModel

        return
    }

    // ... existing save logic ...
}
```

You'll need to adjust the initialization to store the original model from `.grok` into `g.modelFromGrokFile` during loading.

```go
// In LoadFrom function
g.modelFromGrokFile = g.Model
```

#### 5. Ensure All Subcommands Use the Overridden Model

Since the `Grokker` instance is initialized with the correct model, all subcommands that use `g` will automatically use the overridden model without any further changes.

### List of Files to be Changed

1. `cli.go` (located in `/home/stevegt/lab/grokker/v3/cli/cli.go`)
2. `core/api.go` (located in `/home/stevegt/lab/grokker/v3/core/api.go`)
3. `core/grokker.go` (located in `/home/stevegt/lab/grokker/v3/core/grokker.go`)
4. `core/model.go` (located in `/home/stevegt/lab/grokker/v3/core/model.go`)

### Summary

By making these changes, you enable the `-model` flag to override the model used during execution for all subcommands without altering the model stored in `.grok`. This approach ensures that the overridden model is used only for the current execution and doesn't persist between runs, aligning with your requirements.
